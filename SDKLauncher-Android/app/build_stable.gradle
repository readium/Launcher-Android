apply plugin: 'com.android.application'
apply plugin: 'io.fabric'

def ndk_skipX86 = (rootProject.hasProperty("readium_ndk_skipX86") && rootProject.readium_ndk_skipX86)
def ndk_skipARM = (rootProject.hasProperty("readium_ndk_skipARM") && rootProject.readium_ndk_skipARM)

def key_password =  (rootProject.hasProperty("readium_sign_key_password") ? rootProject.readium_sign_key_password : "nope")
def store_password =  (rootProject.hasProperty("readium_sign_store_password") ? rootProject.readium_sign_store_password : "nope")

//def lcpDir = project(':lcp').projectDir
//def epub3Dir = project(':epub3').projectDir
//def rsdkDir = project(':rsdk').projectDir

println "[[${project.name}]] (APP) Skip ARM: ${ndk_skipARM}"
println "[[${project.name}]] (APP) Skip x86: ${ndk_skipX86}"

def currentBuildType
android {
    packagingOptions {
        pickFirst 'lib/armeabi-v7a/libgnustl_shared.so'
        pickFirst 'lib/arm64-v8a/libgnustl_shared.so'
        pickFirst 'lib/x86/libgnustl_shared.so'
        pickFirst 'lib/x86_64/libgnustl_shared.so'
    }

    applicationVariants.all { variant ->
        println "[[${project.name}]] (APP) libraryVariant buildType: ${variant.buildType.name}"

        // currentBuildType = variant.buildType.name
    }

    compileSdkVersion = 28
    buildToolsVersion = "28.0.3"

    lintOptions {
        checkReleaseBuilds = false
        // Or, if you prefer, you can continue to check for errors in release builds,
        // but continue the build even when errors are found:
        abortOnError = false
    }

    signingConfigs {
        create("mySigningConfig") {
            //mySigningConfig {
            keyAlias = 'ReadiumAndroidAPKSign'
            keyPassword = key_password
            storePassword = store_password
            storeType "jks"
            storeFile = file('./ReadiumAndroidAPKSign.jks')
        }
    }

    defaultConfig {
        // manifest@package attribute in src/main/AndroidManifest.xml
        applicationId = "org.readium.sdk.android.launcher"

        // manifest/uses-sdk@android:minSdkVersion attribute in src/main/AndroidManifest.xml
        minSdkVersion 19

        // manifest/uses-sdk@android:targetSdkVersion attribute in src/main/AndroidManifest.xml
        targetSdkVersion 28

        // manifest@android:versionCode attribute in src/main/AndroidManifest.xml
        versionCode 31

        // manifest@android:versionName attribute in src/main/AndroidManifest.xml
        versionName "1.31"
    } //defaultConfig

    sourceSets {
        main {
            java {
                srcDirs = [
                        './src/main/java',
//                         "../../readium-sdk/Platform/Android/lib/src/main/java",
//                         "../../readium-lcp-client/platform/android/lib/src/clientlib/java",
//                         "../../readium-lcp-client/platform/android/lib/src/contentfilter/java"
                        // "${epub3Dir}/../lib/src/main/java",
                        // "${lcpDir}/src/clientlib/java",
                        // "${lcpDir}/src/contentfilter/java"
                ]
            } //java

//             jniLibs {
//                 dependencies {
//                     // project ":rsdk"
//                     // project ":lcp"
//                     project ":readium-sdk"
//                     project ":readium-lcp"
//                 }
//                 // srcDirs = [
//                 //     "${epub3Dir}/jniLibs/RELEASE",
//                 //     "${lcpDir}/jniLibs/RELEASE",
//                 //     "${epub3Dir}/jniLibs/DEBUG",
//                 //     "${lcpDir}/jniLibs/DEBUG"
//                 // ]
//             } //jniLibs
        } //main
    } //sourceSets

    buildTypes {
        debug {
            // sourceSets.main.jniLibs.srcDirs = [
            //     // "${epub3Dir}/jniLibs/DEBUG",
            //     "${lcpDir}/jniLibs/DEBUG"
            // ]
            
            ext.enableCrashlytics = false

            minifyEnabled = false
        }
        release {
            // sourceSets.main.jniLibs.srcDirs = [
            //     // "${epub3Dir}/jniLibs/RELEASE",
            //     "${lcpDir}/jniLibs/RELEASE"
            // ]
            
            ext.enableCrashlytics = false

            minifyEnabled = false
            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
            //proguardFiles.add(file('proguard-rules.txt'))

            signingConfig signingConfigs.mySigningConfig
            //signingConfig $.android.signingConfigs.get("mySigningConfig")
            //signingConfig $("android.signingConfigs.mySigningConfig")
        }
    } //buildTypes

    flavorDimensions "version"
    productFlavors {
        if (!ndk_skipARM && !ndk_skipX86) {
            'armeabi-v7a--arm64-v8a--x86--x86_64' {
                dimension "version"
                // ndk.with {
                //     abiFilters = ['armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64']
                // }
            }
        } else {
            if (!ndk_skipARM) {
                'armeabi-v7a--arm64-v8a' {
                    dimension "version"
                    // ndk.with {
                    //     abiFilters = ['armeabi-v7a', 'arm64-v8a']
                    // }
                }
            }
            if (!ndk_skipX86) {
                'x86--x86_64' {
                    dimension "version"
                    // ndk.with {
                    //     abiFilters = ['x86', 'x86_64']
                    // }
                }
            }
        }
    } //productFlavors
} //android

// task sourceSetJniLibsSrcDirs {
//     doFirst {
//         println ("sourceSetJniLibsSrcDirs: ${currentBuildType}")
//         android.sourceSets.jniLibs.srcDirs = [
//             "${epub3Dir}/libs/${currentBuildType.toUpperCase()}",
//             "${lcpDir}/libs/${currentBuildType.toUpperCase()}"
//         ]
//     }
// }

// tasks.whenTaskAdded { task ->
//     def taskName = task.name

//     if (taskName.startsWith("compile")) {
//         task.dependsOn "sourceSetJniLibsSrcDirs"
//     }
// }

// dependencies {
//     compile project(":lcp")
// }

gradle.taskGraph.whenReady { taskGraph ->
    println "[[${project.name}]] (APP) taskGraph ready"

    // taskGraph.getAllTasks().last().finalizedBy copyLibs
    taskGraph.getAllTasks().last().doLast {
        println "[[${project.name}]] (APP) last TASK (${currentBuildType})"
    } // .dependsOn copyLibs

    if (taskGraph.hasTask(buildRelease)) {
        println "[[${project.name}]] (APP) taskGraph RELEASE (build)"

        currentBuildType = "release"
    } else if (taskGraph.hasTask(buildDebug)) {
        println "[[${project.name}]] (APP) taskGraph DEBUG (build)"

        currentBuildType = "debug"
    } else {
        if (taskGraph.hasTask(assembleRelease)) {
            println "[[${project.name}]] (APP) taskGraph RELEASE (assemble)"

            currentBuildType = "release"
        }
        if (taskGraph.hasTask(assembleDebug)) {
            println "[[${project.name}]] (APP) taskGraph DEBUG (assemble)"

            currentBuildType = "debug"
        }
    }
}

task buildRelease(type: GradleBuild, dependsOn: build) {
}

task buildDebug(type: GradleBuild, dependsOn: build) {
}

// task assembleRelease(type: GradleBuild, dependsOn: assemble) {
// }

// task assembleDebug(type: GradleBuild, dependsOn: assemble) {
// }
